Ddoc

$(SPEC_S Contract Programming,

$(HEADERNAV_TOC)

        $(P Contracts enable specifying conditions that must hold true
        when the flow of runtime execution reaches the contract.
        If a contract is not true, then the program is assumed to have entered
        an undefined state.)

        $(RATIONALE
        $(P Building contract support into the language provides:)

        $(OL
        $(LI a consistent look and feel for the contracts)
        $(LI tool support)
        $(LI the implementation can generate better code using information gathered
        from the contracts)
        $(LI easier management and enforcement of contracts)
        $(LI handling of contract inheritance)
        )
        )

$(HTMLTAG3V img, src="$(ROOT_DIR)images/d4.gif" style="max-width:100%" alt="Contracts make D bug resistant" border="0")

$(H2 $(LNAME2 assert_contracts, Assert Contract))

        $(P See $(GLINK2 expression, AssertExpression).)

$(H2 $(LNAME2 pre_post_contracts, Pre and Post Contracts))

        $(P The pre contracts specify the preconditions before a statement is executed. The most
        typical use of this would be in validating the parameters to a function. The post
        contracts validate the result of the statement. The most typical use of this
        would be in validating the return value of a function and of any side effects it has.
        In D, pre contracts begin with `in`, and post contracts begin with `out`. They
        come at the end of the function signature and before the opening brace of the function body.)

        $(P Pre and post contracts can be written either in expression form (feature introduced in DMD
        2.081.0), with a syntax similar to $(B assert), or as block statements
        containing arbitrary code.)

        $(P The expression form is:)
------
in (expression)
in (expression, "failure string")
out (identifier; expression)
out (identifier; expression, "failure string")
out (; expression)
out (; expression, "failure string")
{
    ...function body...
}
------
        $(P The block statement form is:)
------
in
{
    ...contract preconditions...
}
out
{
    ...contract postconditions...
}
out (identifier)
{
    ...contract postconditions...
}
do
{
    ...function body...
}
------

        $(P The optional identifier in either type of `out` contract is set to the return value
        of the function.)

        $(P By definition, if a pre contract fails, then the function received bad
        parameters. If a post contract fails, then there is a bug in the function. In either case,
        an `assert` statement within the corresponding `in` or `out` block will throw an
        `AssertError`.)

        $(P The keyword `do` can be used to announce the function body. Although any number
        of pre or post contracts of any form may follow each other, `do` is
        required only when the last contract before the body is a block statement.
        (Before the acceptance of
        $(LINK2 https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md, DIP1003),
        the keyword `body` was required instead of `do`, and may still be encountered in
        old code bases. In the long term, `body` may be deprecated, but for now it's allowed both
        as a keyword in this context and as an identifier elsewhere, although `do` is preferred.) )

        $(P Though any arbitrary D code is allowed in the `in` and `out` contract blocks,
        their only function should be to verify incoming and outgoing data. It is important
        to ensure that the
        code has no side effects, and that the release version of the code
        will not depend on any  effects of the code.
        For a release build of the code, `in` and `out` contracts are not
        inserted.)

        $(P Here is an example function in both forms:)

------
int fun(ref int a, int b)
in (a > 0)
in (b >= 0, "b cannot be negative!")
out (r; r > 0, "return must be positive")
out (; a != 0)
{
    // function body
}

int fun(ref int a, int b)
in
{
    assert(a > 0);
    assert(b >= 0, "b cannot be negative!");
}
out (r)
{
    assert(r > 0, "return must be positive");
    assert(a != 0);
}
do
{
    // function body
}
------

        $(P The two functions are almost identical semantically. The expressions in the
        first are lowered to contract blocks that look almost exactly like the second,
        except that a separate block is created for each expression in the first, thus
        avoiding shadowing variable names.)

$(H2 $(LNAME2 in_out_inheritance, In, Out and Inheritance))

        $(P If a function in a derived class overrides a function from its
        super class, then only one of
        the $(D in) contracts of the function and its base functions
        must be satisfied.
        Overriding
        functions then becomes a process of $(I loosening) the $(D in)
        contracts.
        )

        $(P A function without an $(D in) contract means that any values
        of the function parameters are allowed. This implies that if any
        function in an inheritance hierarchy has no $(D in) contract,
        then any $(D in) contracts on functions overriding it have no useful
        effect.
        )

        $(P Conversely, all of the $(D out) contracts need to be satisfied,
        so overriding functions becomes a processes of $(I tightening) the
        $(D out)
        contracts.
        )

$(H2 $(LNAME2 Invariants, Invariants))

        $(P See $(DDSUBLINK struct, StructInvariant, Struct Invariants) and $(DDSUBLINK class, invariants, Class Invariants).)


$(H2 $(LNAME2 references, References))

        $(LIST
        $(LINK2 https://web.archive.org/web/20080919174640/http://people.cs.uchicago.edu/~robby/contract-reading-list/, Contracts Reading List),
        $(LINK2 http://jan.newmarch.name/java/contracts/paper-long.html, Adding Contracts to Java)
        )

$(SPEC_SUBNAV_PREV_NEXT template-mixin, Template Mixins, version, Conditional Compilation)
)

Macros:
        CHAPTER=23
        TITLE=Contract Programming

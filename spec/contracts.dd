Ddoc

$(SPEC_S Contract Programming,

$(HEADERNAV_TOC)

        $(P Contracts enable specifying conditions that must hold true
        when the flow of runtime execution reaches the contract.
        If a contract is not true, then the program is assumed to have entered
        an undefined state.)

        $(RATIONALE
        $(P Building contract support into the language provides:)

        $(OL
        $(LI a consistent look and feel for the contracts)
        $(LI tool support)
        $(LI the implementation can generate better code using information gathered
        from the contracts)
        $(LI easier management and enforcement of contracts)
        $(LI handling of contract inheritance)
        )
        )

$(HTMLTAG3V img, src="$(ROOT_DIR)images/d4.gif" style="max-width:100%" alt="Contracts make D bug resistant" border="0")

$(H2 $(LNAME2 assert_contracts, Assert Contract))

        $(P See $(GLINK2 expression, AssertExpression).)

$(H2 $(LNAME2 pre_post_contracts, Pre and Post Contracts))

        $(P See $(LINK2 function, contracts). )

$(H2 $(LNAME2 Invariants, Invariants))

        $(P Invariants are used to specify characteristics of a class or struct that
        must always be true (except while executing a member function).
        For example, a class representing a date might have an invariant that the
        day must be 1..31 and the hour must be 0..23:
        )

------
class Date
{
    int day;
    int hour;

    this(int d, int h)
    {
        day = d;
        hour = h;
    }

    invariant
    {
        assert(1 <= day && day <= 31);
        assert(0 <= hour && hour < 24, "hour out of bounds");
    }
}
------

        $(P Invariant blocks should contain `assert` expressions, and should throw
        `AssertError`s when they fail. Since DMD version 2.081.0,
        invariants can also be written as expression statements, with `assert` implied:
        )

------
    invariant (1 <= day && day <= 31);
    invariant (0 <= hour && hour < 24, "hour out of bounds");
------

        $(P The invariant is a contract saying that the `assert`s must hold true.
        The invariant is checked when a class or struct constructor completes,
        and at the start of the class or struct destructor. For public or exported
        functions, the order of execution is:
        )

        $(OL
        $(LI preconditions)
        $(LI invariant)
        $(LI function body)
        $(LI invariant)
        $(LI postconditions)
        )

        $(P The invariant is not checked if the class or struct is implicitly constructed using
        the default $(CODE .init) value.
        )

        $(P The code in the invariant may not call any public non-static members
        of the class or struct, either directly or indirectly.
        Doing so will result in a stack overflow, as the invariant will wind
        up being called in an infinitely recursive manner.
        )

        $(P Invariants are implicitly `const`.)

        $(P Since the invariant is called at the start of public or
        exported members, such members should not be called from
        constructors.
        )

------
class Foo
{
    public void f() { }
    private void g() { }

    invariant
    {
        f();  // error, cannot call public member function from invariant
        g();  // ok, g() is not public
    }
}
------

        $(P The invariant can be checked with an $(CODE assert()) expression:)

        $(OL
        $(LI classes need to pass a class object)
        $(LI structs need to pass the address of an instance)
        )

------
auto mydate = new Date(); //class
auto s = S();             //struct
...
assert(mydate);           // check that class Date invariant holds
assert(&s);               // check that struct S invariant holds
------

        $(P Class invariants are inherited, that is,
        any class invariant is implicitly in addition to the invariants of its base
        classes.)

        $(P There can be more than one invariant declared per class or struct.)

        $(P When compiling for release, the invariant code is not generated, and the compiled program runs at maximum speed.
        The compiler is free to assume the invariant holds true, regardless of whether code is generated for it or not, and
        may optimize code accordingly.)

$(H2 $(LNAME2 references, References))

        $(LIST
        $(LINK2 https://web.archive.org/web/20080919174640/http://people.cs.uchicago.edu/~robby/contract-reading-list/, Contracts Reading List),
        $(LINK2 http://jan.newmarch.name/java/contracts/paper-long.html, Adding Contracts to Java)
        )

$(SPEC_SUBNAV_PREV_NEXT template-mixin, Template Mixins, version, Conditional Compilation)
)

Macros:
        CHAPTER=23
        TITLE=Contract Programming
